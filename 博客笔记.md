# 白卷博客

原文链接：https://blog.csdn.net/Neuf_Soleil/article/details/89422585

### 1.登录模块



#### 1.前端路由与登录拦截器

首先我们把 Vue 中配置的路由从默认的 `hash` 模式切换为 `histroy` 模式。打开我们的前端项目 `wj-vue`，修改 `router\index.js`，加入 `mode: 'history` 这句话。整体代码如下

```javascript
export default new Router({
  mode: 'history',//项目访问地址就没有#了，否则会有#
  routes: [
    {
      path: '/login',
      name: 'Login',
      component: Login
    }
  ]
})
原文链接：https://blog.csdn.net/Neuf_Soleil/article/details/89422585
```



#### 2.打包

接下来，我们把前端打包后部署在后端。这不是前后端分离项目推荐的做法，之前我们讲过其实应该把前后端分别部署在不同的服务器中，但实际上仍有不少项目会选择把前后端整合在一起，只使用一个服务器，所以这里我们也提及一下这种方式，但在之后的开发中不会这样部署。

先在项目目录执行 npm run build



这时在项目的 dist 文件夹下生成了 assets 文件夹和 index.html 文件，把这两个文件，拷贝到我们后端项目的 wj\src\main\resources\static 文件夹下(拷完idea中目录大概是：resources--static-assets-css/js/index.html/.....)，一定要注意这个位置，这时后端配置的静态文件的 path，虽然看起来很诡异，但一般都不作修改
————————————————

接下来，打开后端项目并运行，访问 http://localhost:8443/index.html ，（注意输入后缀 .html）发现页面是空白的，但确实取到了这个页面，再访问 http://localhost:8443/login ,发现跳转到了错误页面（White Error Page）




#### 3.单页面应用的概念

在我们这个项目中，其实只有 index.html 这一个页面，所有的其它内容都是在这个页面里动态渲染的。当我们直接在后端访问 /login 路径时，服务器会后端并没有这个路径对应的内容，所以返回了 Error Page。

为了获取到我们需要的内容，我们要想办法触发前端路由，即在后端添加处理内容，把 通过这个 URL 渲染出的 index.html 返回到浏览器。

在后端项目中新建一个 package 名为 error，新建实现 ErrorPageRegistrar 接口的类 ErrorConfig，把默认的错误页面设置为 /index.html(大概就是前端页面入口)，代码如下

```java
@Component
public class ErrorConfig implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, "/index.html");
        registry.addErrorPages(error404Page);
    }

}

```



#### 4.后端登录拦截器



为了完善登录功能，我们需要限制未登录状态下对核心功能页面的访问。登录拦截可以由多种方式来实现，我们首先讲解后端拦截器的开发。（注意如果没有把前后端项目整合起来，就没有办法使用这种方式） 



一个简单拦截器的逻辑如下：

1.用户访问 URL，检测是否为登录页面，如果是登录页面则不拦截
 2.如果用户访问的不是登录页面，检测用户是否已登录，如果未登录则跳转到登录页面



修改 LoginController 的内容。之前我们实现了通过查询数据库验证用户名是否正确，但仅此而已。

为了保存登录状态，我们可以把用户信息存在 Session 对象中（当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量不会丢失），这样在访问别的页面时，可以通过判断是否存在用户变量来判断用户是否登录。这是一种比较简单的方式，感兴趣的同学可以尝试别的方法。

修改后的代码内容如下：

```java
package com.evan.wj.controller;

import com.evan.wj.pojo.User;
import com.evan.wj.result.Result;
import com.evan.wj.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.HtmlUtils;

import javax.servlet.http.HttpSession;

@Controller
public class LoginController {

    @Autowired
    UserService userService;

    @CrossOrigin
    @PostMapping(value = "/api/login")
    @ResponseBody
    public Result login(@RequestBody User requestUser, HttpSession session) {
        String username = requestUser.getUsername();
        username = HtmlUtils.htmlEscape(username);

        User user = userService.get(username, requestUser.getPassword());
        if (null == user) {
            return new Result(400);
        } else {
            session.setAttribute("user", user);
            return new Result(200);
        }
    }
}

```

其实只是添加了一条语句 `session.setAttribute("user", user);` 



#### 5.LoginInterceptor

新建 package 名为 interceptor，新建类 LoginInterceptor。

Interceptor 即拦截器，在 Springboot 我们可以直接继承拦截器的接口，然后实现 preHandle 方法。preHandle 方法里的代码会在访问需要拦截的页面时执行。

代码如下：

```java
package com.evan.wj.interceptor;

import com.evan.wj.pojo.User;
import org.apache.commons.lang.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class LoginInterceptor  implements HandlerInterceptor{

    @Override
    public boolean preHandle (HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        HttpSession session = httpServletRequest.getSession();
        String contextPath=session.getServletContext().getContextPath();//项目名
        String[] requireAuthPages = new String[]{
                "index",
        };

        String uri = httpServletRequest.getRequestURI();//例：/store/UserServlet，url除去IP：端口，以及？后的参数剩下的

        uri = StringUtils.remove(uri, contextPath+"/");//删除 项目名/ 剩下：UserServlet
        String page = uri;

        if(begingWith(page, requireAuthPages)){//若uri以index开头，或者MyWebConfigurer中配置的拦截请求，就判断是否登录，没登录调到登录页面
            User user = (User) session.getAttribute("user");
            if(user==null) {
                httpServletResponse.sendRedirect("login");
                return false;
            }
        }
        return true;
    }

    private boolean begingWith(String page, String[] requiredAuthPages) {
        boolean result = false;
        for (String requiredAuthPage : requiredAuthPages) {
            if(StringUtils.startsWith(page, requiredAuthPage)) {
                result = true;
                break;
            }
        }
        return result;
    }
}

```

其实就是判断 session 中是否存在 user 属性，如果存在就放行，如果不存在就跳转到 login 页面.

拓展:

```mark
request.getServletPath()

首先从字面我们就知道这个方法获得的是servlet的路径
假如我们在tomcat下部署了一个名为store的项目
我们访问：http://localhost:8080/store/UserServlet?method=findByName
其中UserServlet就是我们的servlet，那么如果

system.out.println(request.getServletPath);
//输出结果就是/UserServlet 记住不带参数
---------------------------------------------------------------------------------------

现在大家明白了吧，这个方法获取的是包括servlet之后的路径，不包括项目名的路径。
request.getContextPath()

首先从字面我们知道contextpath的意思是容器的路径，我们可以把context理解为项目。
所以这个方法获取的就是项目名路径

system.out.println(request.getContextPath());
//输出结果就是/store
---------------------------------------------------------------------------------------

request.getRequestURI()

在图解http这本书中，解释到URI是uniform resource identifier（统一资源标识符）
而URL是uniform resource locator（统一资源定位符）
RFC2396对这URI三个单词有一定的解释：
uniform：可以简单理解为http或者ftp协议以及其他协议。
resource：可以理解为可标识的任何东西。
identifier：可标识的对象，也就是标识符。
那么，综上所述，URI是在满足一定的协议下某些资源的定位标识符。

system.out.println(request.getRequestURI());
//输出结果就是/store/UserServlet
---------------------------------------------------------------------------------------

request.getRequestURL()

system.out.println(request.getRequestURL());
//输出结果就是http://localhost:8080/store/UserServlet

---------------------------------------------------------------------------------------
以下是网上的一些解释。

    getServletPath():获取能够与“url-pattern”中匹配的路径，注意是完全匹配的部分，*的部分不包括。
    getPageInfo():与getServletPath()获取的路径互补，能够得到的是“url-pattern”中*d的路径部分
    getContextPath():获取项目的根路径
    getRequestURI:获取根路径到地址结尾
    getRequestURL:获取请求的地址链接（浏览器中输入的地址）
    getServletContext().getRealPath(“/”):获取“/”在机器中的实际地址
    getScheme():获取的是使用的协议(http 或https)
    getProtocol():获取的是协议的名称(HTTP/1.11)
    getServerName():获取的是域名(xxx.com)
    getLocalName:获取到的是IP

```





#### 6.WebConfigurer

我们写完了拦截器，但是它却并不会生效，因为我们还没有把它配置到项目中。

新建 package 名为 `config`，新建类 `MyWebConfigurer`，代码如下

```java
package com.evan.wj.config;

import com.evan.wj.interceptor.LoginInterceptor;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.web.servlet.config.annotation.*;

@SpringBootConfiguration
public class MyWebConfigurer implements WebMvcConfigurer {

    @Bean
    public LoginInterceptor getLoginIntercepter() {
        return new LoginInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry){
        registry.addInterceptor(getLoginIntercepter()).addPathPatterns("/**").excludePathPatterns("/index.html");
    }
}

```



```java
registry.addInterceptor(getLoginIntercepter()).addPathPatterns("/**").excludePathPatterns("/index.html");
```

这条语句的作用是对所有路径应用拦截器，除了 /index.html。

之前我们在拦截器 LoginInterceptor 中配置的路径，即 index，触发的时机是在拦截器生效之后。也就是说，我们访问一个 URL，会首先通过 Configurer 判断是否需要拦截，如果需要，才会触发拦截器 LoginInterceptor，根据我们自定义的规则进行再次判断。

/index 与 /index.html 是不同的，也就是说 /index 会触发拦截器而 /index.html 不会，但根据拦截器 LoginInterceptor 中我们定义的判断条件，以 /index 开头的路径都会被转发，包括 index.html。

因为我们做的是单页面应用，之前通过配置 ErrorPage，实际上访问所有路径都会重定向到 /index.html 。我们直接在浏览器地址栏输入 /index 会触发拦截器，经过拦截器重定向到 /login，然后 /login 再经过 Configurer 的判断，再次触发拦截器，由于不在需要拦截的路径中，所以被放行，页面则重新定向到了 /index.html，如果没有再 Configurer 中取消对 /index.html 的拦截，则会再次触发拦截器，再次重定向到 /login



#### 7.Vuex 与前端登录拦截器



##### 7.1 vuex设置

前面我们使用了后端拦截器，但这种拦截器只有在将前后端项目整合在一起时才能生效，而前后端分离的项目实际上不推荐这么做，接下来我们尝试用前端实现相似的功能。

实现前端登录器，需要在前端判断用户的登录状态。**我们可以像之前那样在组件的 data 中设置一个状态标志，但登录状态应该被视为一个全局属性，而不应该只写在某一组件中。所以我们需要引入一个新的工具——Vuex**，它是专门为 Vue 开发的状态管理方案，我们可以把需要在各个组件中传递使用的变量、方法定义在这里。之前我一直没有使用它，所以在不同组件传值的问题上十分头疼，要写很多多余的代码来调用不同组件的值，所以推荐大家从一开始就去熟悉这种管理方式。

之后，我们在 index.js  里设置我们需要的状态变量和方法。为了实现登录拦截器，我们需要一个记录用户信息的变量。为了方便日后的扩展（权限认证等），我们使用一个用户对象而不是仅仅使用一个布尔变量。同时，设置一个方法，触发这个方法时可以为我们的用户对象赋值。完整的代码如下： 

```java
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    user: {
      //localStorage，即本地存储，在项目打开的时候会判断本地存储中是否有 user 这个对象存在，如果存在就取出来并获得 username 的值，否则则把 username 设置为空。这样我们只要不清除缓存，登录的状态就会一直保存
      username: window.localStorage.getItem('user' || '[]') == null ? '' : JSON.parse(window.localStorage.getItem('user' || '[]')).username
    }
  },
  mutations: {
    login (state, user) {
      state.user = user
      window.localStorage.setItem('user', JSON.stringify(user))
    }
  }
})

```



##### 7.2修改路由设置

为了区分页面是否需要拦截，我们需要修改一下 `src\router\index.js`，在需要拦截的路由中加一条元数据，设置一个 `requireAuth` 字段如下：

```javascript
{
      path: '/index',
      name: 'AppIndex',
      component: AppIndex,
      meta: {
        requireAuth: true
      }
}
```



##### 7.3使用钩子函数判断是否拦截

钩子函数及在某些时机会被调用的函数。这里我们使用 `router.beforeEach()`，意思是在访问每一个路由前调用。

打开 `src\main.js` ，首先添加对 `store` 的引用,并添加内容 

```javascript

router.beforeEach((to, from, next) => {
    if (to.meta.requireAuth) {
      if (store.state.user.username) {
        next()
      } else {
        next({
          path: 'login',
          query: {redirect: to.fullPath}
        })
      }
    } else {
      next()
    }
  }
)

```



##### 7.4修改 Login.vue

修改后的逻辑如下：

1.点击登录按钮，向后端发送数据
2.受到后端返回的成功代码时，触发 store 中的 login() 方法，把 loginForm 对象传递给 store 中的 user 对象
（*这里只是简单的实现，在后端我们可以通过用户名和密码查询数据库，获得 user 表的完整信息，比如用户昵称、用户级别等，返回前端，并传递给 user 对象，以实现更复杂的功能）
3.获取登录前页面的路径并跳转，如果该路径不存在，则跳转到首页

修改后的 login() 方法如下：

```javascript
login () {
  var _this = this
  console.log(this.$store.state)
  this.$axios
    .post('/login', {
      username: this.loginForm.username,
      password: this.loginForm.password
    })
    .then(successResponse => {
      if (successResponse.data.code === 200) {
        // var data = this.loginForm
        _this.$store.commit('login', _this.loginForm)
        var path = this.$route.query.redirect
        this.$router.replace({path: path === '/' || path === undefined ? '/index' : path})
      }
    })
    .catch(failResponse => {
    })
}

```

route相当于当前正在跳转的路由对象。。可以从里面获取name,path,params,query等 



router为VueRouter的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如history对象。。。经常用的跳转链接就可以用this.$router.push，和router-link跳转一样。。。 

